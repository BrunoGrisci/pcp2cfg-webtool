<!-- Bruno Iochins Grisci 2025-2026 ‚Äî pcp2cfg -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PCP ‚Üí CFG Ambiguity (pcp2cfg)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Optional favicon: reuse your domino icon if you want -->
  <!-- <link rel="icon" href="images/domino.png"> -->

  <style>
    :root {
      --bg: #ffffff;
      --fg: #222222;
      --panel-bg: #ffffff;
      --panel-border: #dddddd;
      --workspace-border: #bbbbbb;
      --status-ok: #333333;
      --status-err: darkred;
      --small-note: #555555;

      --chip-bg: #f3f4f6;
      --chip-border: #d1d5db;

      --tree-node-bg: #ffffff;
      --tree-node-border: #d1d5db;
      --tree-edge: #9ca3af;
    }

    body.dark-mode {
      --bg: #101215;
      --fg: #e5e7eb;
      --panel-bg: #111827;
      --panel-border: #374151;
      --workspace-border: #4b5563;
      --status-ok: #e5e7eb;
      --status-err: #fca5a5;
      --small-note: #9ca3af;

      --chip-bg: #0f172a;
      --chip-border: #334155;

      --tree-node-bg: #0b1220;
      --tree-node-border: #334155;
      --tree-edge: #64748b;
    }

    body {
      font-family: system-ui, sans-serif;
      margin: 1.5rem;
      background: var(--bg);
      color: var(--fg);
      transition: background 0.2s ease, color 0.2s ease;
    }

    h1 {
      font-size: 1.4rem;
      margin: 0 0 0.5rem 0;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    a { color: inherit; text-decoration: underline; }
    a:hover { text-decoration: none; }

    .topbar {
      display: flex;
      align-items: flex-start;
      gap: 1rem;
      flex-wrap: wrap;
    }
    .topbar .spacer { flex: 1 1 auto; }

    .top-right-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-left: auto;
    }

    .icon-switch {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
      padding: 0.25rem 0.5rem;
      border: 1px solid var(--panel-border);
      background: var(--panel-bg);
      color: var(--fg);
      border-radius: 999px;
      cursor: pointer;
      user-select: none;
      font-size: 1rem;
      line-height: 1;
    }
    .icon-switch:hover { filter: brightness(0.98); }
    body.dark-mode .icon-switch:hover { filter: brightness(1.08); }
    .icon-switch[aria-pressed="true"] {
      box-shadow: 0 0 0 2px rgba(59,130,246,0.35);
    }

    .row {
      display: flex;
      gap: 1rem;
      margin: 0.75rem 0 1rem 0;
      flex-wrap: wrap;
      align-items: flex-end;
    }

    label { font-weight: 600; }

    input[type="text"], textarea, input[type="file"] {
      background: var(--panel-bg);
      color: var(--fg);
      border: 1px solid var(--panel-border);
      border-radius: 0.35rem;
      padding: 0.35rem 0.5rem;
    }

    button {
      padding: 0.45rem 0.85rem;
      border-radius: 0.5rem;
      border: 1px solid var(--panel-border);
      cursor: pointer;
      background: var(--panel-bg);
      color: var(--fg);
    }
    button:hover { background: #f3f3f3; }
    body.dark-mode button:hover { background: #1f2937; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }

    .panel {
      border: 1px solid var(--panel-border);
      border-radius: 0.75rem;
      padding: 0.9rem;
      background: var(--panel-bg);
    }

    .split-container {
      display: flex;
      gap: 0;
      margin-top: 1rem;
      min-height: 300px;
    }

    #leftPane, #rightPane { min-width: 240px; }
    .divider {
      width: 5px;
      cursor: col-resize;
      background: var(--panel-border);
      flex: 0 0 auto;
    }
    body.dark-mode .divider { background: #4b5563; }

    .panel h2 {
      font-size: 1.05rem;
      margin: 0 0 0.5rem 0;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .small-note {
      font-size: 0.85rem;
      color: var(--small-note);
      margin-top: 0.25rem;
      line-height: 1.35;
    }

    #status {
      margin-top: 0.75rem;
      white-space: pre-wrap;
      font-size: 0.95rem;
    }

    /* ---------- Help modal ---------- */
    .help-btn {
      width: 1.35rem;
      height: 1.35rem;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      font-weight: 700;
      border: 1px solid var(--panel-border);
      background: var(--panel-bg);
      color: var(--fg);
      cursor: pointer;
      user-select: none;
    }
    .help-btn:hover { filter: brightness(0.98); }
    body.dark-mode .help-btn:hover { filter: brightness(1.08); }
    .help-btn:focus { outline: 2px solid #60a5fa; outline-offset: 2px; }

    .help-overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.5);
      z-index: 9999;
      padding: 1.25rem;
    }
    body.dark-mode .help-overlay { background: rgba(0,0,0,0.65); }
    .help-overlay.open { display: flex; }
    body.help-open { overflow: hidden; }

    .help-modal {
      width: min(900px, 96vw);
      max-height: min(85vh, 900px);
      overflow: auto;
      background: var(--panel-bg);
      color: var(--fg);
      border: 1px solid var(--panel-border);
      border-radius: 0.9rem;
      box-shadow: 0 16px 50px rgba(0,0,0,0.25);
    }
    body.dark-mode .help-modal { box-shadow: 0 20px 60px rgba(0,0,0,0.55); }

    .help-modal-header {
      position: sticky;
      top: 0;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.85rem 1rem;
      background: var(--panel-bg);
      border-bottom: 1px solid var(--panel-border);
    }
    .help-modal-title {
      font-size: 1.05rem;
      font-weight: 700;
      margin: 0;
    }
    .help-modal-close {
      margin-left: auto;
      width: 2rem;
      height: 2rem;
      border-radius: 999px;
      border: 1px solid var(--panel-border);
      background: var(--panel-bg);
      color: var(--fg);
      cursor: pointer;
      font-size: 1.05rem;
      line-height: 1;
    }

    .help-modal-body {
      padding: 1rem 1rem 1.15rem 1rem;
      font-size: 0.95rem;
      line-height: 1.5;
    }
    .help-modal-body h3 { margin: 0.85rem 0 0.35rem 0; font-size: 1rem; }
    .help-modal-body p { margin: 0.5rem 0; }
    .help-modal-body ul { margin: 0.35rem 0 0.75rem 1.15rem; }
    .help-modal-body code {
      background: rgba(0,0,0,0.06);
      padding: 0.1rem 0.25rem;
      border-radius: 0.25rem;
    }
    body.dark-mode .help-modal-body code { background: rgba(255,255,255,0.08); }

    /* ---------- Domino editor ---------- */
    .domino-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.92rem;
    }
    .domino-table th, .domino-table td {
      border: 1px solid var(--panel-border);
      padding: 0.4rem 0.45rem;
      vertical-align: top;
    }
    .domino-table th {
      background: rgba(0,0,0,0.03);
      text-align: left;
      position: sticky;
      top: 0;
    }
    body.dark-mode .domino-table th { background: rgba(255,255,255,0.05); }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      border: 1px solid var(--chip-border);
      background: var(--chip-bg);
      font-size: 0.85rem;
      white-space: nowrap;
    }

    .danger { color: #dc2626; }
    body.dark-mode .danger { color: #fca5a5; }
    .good { color: #16a34a; }
    body.dark-mode .good { color: #86efac; }

    /* ---------- Grammar ---------- */
    pre.grammar {
      white-space: pre-wrap;
      border: 1px dashed var(--workspace-border);
      border-radius: 0.6rem;
      padding: 0.75rem;
      background: rgba(0,0,0,0.02);
      margin: 0.6rem 0 0.25rem 0;
      font-size: 0.92rem;
    }
    body.dark-mode pre.grammar { background: rgba(255,255,255,0.04); }

    /* ---------- Derivation trees ---------- */
    .tree-wrap {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      margin-top: 0.75rem;
    }
    .tree-panel {
      flex: 1 1 320px;
      min-width: 280px;
      border: 1px solid var(--panel-border);
      border-radius: 0.75rem;
      padding: 0.75rem;
      background: rgba(0,0,0,0.015);
    }
    body.dark-mode .tree-panel { background: rgba(255,255,255,0.03); }

    .tree-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      margin: 0 0 0.4rem 0;
      font-weight: 700;
    }

    .tree {
      font-size: 0.92rem;
      overflow-x: auto;
      padding-bottom: 0.5rem;
    }

    /* Simple DOM tree layout (UL-based) */
    .tree ul {
      padding-top: 18px;
      position: relative;
      display: inline-block;
      padding-left: 0;
      margin: 0;
      white-space: nowrap;
    }
    .tree li {
      display: inline-block;
      text-align: center;
      list-style-type: none;
      position: relative;
      padding: 18px 8px 0 8px;
      vertical-align: top;
    }
    .tree li::before, .tree li::after {
      content: '';
      position: absolute;
      top: 0;
      right: 50%;
      border-top: 1px solid var(--tree-edge);
      width: 50%;
      height: 18px;
    }
    .tree li::after {
      right: auto;
      left: 50%;
      border-left: 1px solid var(--tree-edge);
      width: 50%;
    }
    .tree li:only-child::after, .tree li:only-child::before {
      display: none;
    }
    .tree li:only-child { padding-top: 0; }

    .tree li:first-child::before, .tree li:last-child::after {
      border: 0 none;
    }
    .tree li:last-child::before {
      border-right: 1px solid var(--tree-edge);
      border-radius: 0 6px 0 0;
    }
    .tree li:first-child::after {
      border-radius: 6px 0 0 0;
    }

    .tree li .node {
      display: inline-block;
      border: 1px solid var(--tree-node-border);
      padding: 0.2rem 0.55rem;
      border-radius: 0.6rem;
      background: var(--tree-node-bg);
      min-width: 2.2rem;
    }

    .tree .node.nonterm { font-weight: 700; }
    .tree .node.term { font-family: ui-monospace, Menlo, Consolas, monospace; }

    .result-box {
      margin-top: 0.6rem;
      border: 1px solid var(--panel-border);
      border-radius: 0.75rem;
      padding: 0.6rem 0.75rem;
    }

    .app-footer {
      margin-top: 2rem;
      padding-top: 0.75rem;
      border-top: 1px solid var(--panel-border);
      font-size: 0.8rem;
      color: var(--small-note);
    }
    .footer-inner {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    @media (min-width: 700px) {
      .footer-inner {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }
    }
  </style>
</head>

<body>
  <div class="topbar">
    <h1>
      <span data-i18n="title.main">PCP ‚Üí CFG Ambiguity (pcp2cfg)</span>
      <button type="button" class="help-btn" data-help="main_tool" aria-label="Help">?</button>
    </h1>

    <div class="spacer"></div>

    <div class="top-right-controls">
      <button type="button" id="darkModeSwitch" class="icon-switch" aria-pressed="false">
        <span id="darkModeIcon" class="icon">‚òÄÔ∏è</span>
      </button>
      <button type="button" id="langSwitch" class="icon-switch" aria-pressed="false">
        <span id="langIcon" class="icon">üá¨üáß</span>
      </button>
    </div>
  </div>

  <div style="margin: 0.25rem 0 0.75rem 0; font-size:0.86rem; line-height:1.35;">
    <strong data-i18n="about.line1">An interactive tool for the reduction PCP ‚áí CFG Ambiguity.</strong><br />
    <span data-i18n="about.line2">Build or import a PCP instance (dominoes), generate the grammar G_D, and explore derivations via T and B.</span><br />
    <em data-i18n="about.note_ai">(Webtool built using Generative AI ‚Äî ChatGPT)</em>
  </div>

  <div class="row">
    <div>
      <label for="csvFile">
        <span data-i18n="label.csv_file">Import dominoes (.csv):</span>
        <button type="button" class="help-btn" data-help="csv_import" aria-label="Help">?</button>
      </label><br />
      <input type="file" id="csvFile" accept=".csv" />
    </div>

    <div style="display:flex; gap:0.5rem; flex-wrap:wrap;">
      <button id="addDominoBtn" data-i18n="button.add_domino">Add domino</button>
      <button id="clearDominoesBtn" data-i18n="button.clear_dominoes">Clear dominoes</button>
      <button id="exportCsvBtn" data-i18n="button.export_csv">Export CSV</button>
    </div>
  </div>

  <div id="status"></div>

  <div class="split-container">
    <div id="leftPane" class="panel" style="flex: 1 1 45%;">
      <h2>
        <span data-i18n="title.dominoes">PCP instance (dominoes)</span>
        <button type="button" class="help-btn" data-help="dominoes" aria-label="Help">?</button>
      </h2>
      <div class="small-note" data-i18n="note.dominoes">
        Each domino i is a pair (t_i, b_i). The tool assigns a new terminal a_i used as an index marker in the grammar.
      </div>

      <div style="max-height: 340px; overflow:auto; margin-top:0.65rem;">
        <table class="domino-table" aria-label="Domino table">
          <thead>
            <tr>
              <th style="width:6.5rem;"><span data-i18n="domino.header.id">ID</span></th>
              <th><span data-i18n="domino.header.top">Top (t_i)</span></th>
              <th><span data-i18n="domino.header.bottom">Bottom (b_i)</span></th>
              <th style="width:6rem;"><span data-i18n="domino.header.actions">Actions</span></th>
            </tr>
          </thead>
          <tbody id="dominoTbody"></tbody>
        </table>
      </div>

      <div class="result-box" style="margin-top:0.75rem;">
        <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap;">
          <span class="chip">
            <strong data-i18n="summary.k">k</strong> =
            <span id="kCount">0</span>
          </span>
          <span class="chip">
            <strong data-i18n="summary.ai">Index symbols</strong>:
            <span id="aiSummary" class="mono">‚àÖ</span>
          </span>
        </div>
        <div class="small-note" data-i18n="note.ai_symbols" style="margin-top:0.35rem;">
          The symbols a1, a2, ‚Ä¶ are fresh terminals that do not appear in any t_i or b_i.
        </div>
      </div>
    </div>

    <div id="divider" class="divider" title="Drag to resize"></div>

    <div id="rightPane" class="panel" style="flex: 1 1 55%;">
      <h2>
        <span data-i18n="title.grammar">Generated CFG G_D</span>
        <button type="button" class="help-btn" data-help="grammar" aria-label="Help">?</button>
      </h2>

      <div class="small-note" data-i18n="note.grammar">
        The grammar is constructed from your dominoes using the classical reduction PCP ‚áí AMB_CFG.
      </div>

      <pre id="grammarBox" class="grammar mono"></pre>

      <hr style="margin: 0.85rem 0; border: none; border-top: 1px solid var(--panel-border);" />

      <h2 style="margin-top:0;">
        <span data-i18n="title.derivations">Derivation explorer</span>
        <button type="button" class="help-btn" data-help="derivations" aria-label="Help">?</button>
      </h2>

      <div class="row" style="margin-top:0.6rem;">
        <div style="flex: 1 1 280px;">
          <label for="seqInput">
            <span data-i18n="label.sequence">Index sequence (e.g., 1,3,2):</span>
            <button type="button" class="help-btn" data-help="sequence" aria-label="Help">?</button>
          </label><br />
          <input type="text" id="seqInput" placeholder="1,2,1" style="width:min(420px, 100%);" />
          <div class="small-note" data-i18n="note.sequence">
            This builds two derivations: S‚áíT‚áí* and S‚áíB‚áí*. Matching outputs witness ambiguity.
          </div>
        </div>

        <div style="display:flex; gap:0.5rem; flex-wrap:wrap;">
          <button id="buildDerivBtn" data-i18n="button.build_derivation">Build derivations</button>
          <button id="exampleBtn" data-i18n="button.load_example">Load example</button>
        </div>
      </div>

      <div class="result-box">
        <div style="display:flex; gap:0.6rem; align-items:center; flex-wrap:wrap;">
          <span class="chip">
            <span data-i18n="result.top_concat">Top concat</span>:
            <span id="topConcat" class="mono">‚Äì</span>
          </span>
          <span class="chip">
            <span data-i18n="result.bottom_concat">Bottom concat</span>:
            <span id="bottomConcat" class="mono">‚Äì</span>
          </span>
          <span class="chip">
            <span data-i18n="result.word_T">Word via T</span>:
            <span id="wordT" class="mono">‚Äì</span>
          </span>
          <span class="chip">
            <span data-i18n="result.word_B">Word via B</span>:
            <span id="wordB" class="mono">‚Äì</span>
          </span>
        </div>

        <div id="matchLine" class="small-note" style="margin-top:0.55rem;"></div>
      </div>

      <div class="tree-wrap">
        <div class="tree-panel">
          <div class="tree-title">
            <span class="mono">S ‚áí T ‚áí* ‚Ä¶</span>
            <span class="chip"><span data-i18n="tree.label">Tree</span> T</span>
          </div>
          <div id="treeT" class="tree"></div>
        </div>

        <div class="tree-panel">
          <div class="tree-title">
            <span class="mono">S ‚áí B ‚áí* ‚Ä¶</span>
            <span class="chip"><span data-i18n="tree.label">Tree</span> B</span>
          </div>
          <div id="treeB" class="tree"></div>
        </div>
      </div>

      <div class="small-note" data-i18n="note.undecidable" style="margin-top:0.75rem;">
        Reminder: this tool does not decide PCP or CFG ambiguity. It helps you explore the reduction and witness ambiguity when a solution is found.
      </div>
    </div>
  </div>

  <!-- Help modal overlay -->
  <div id="helpOverlay" class="help-overlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="help-modal" role="document">
      <div class="help-modal-header">
        <h3 id="helpTitle" class="help-modal-title"></h3>
        <button type="button" id="helpCloseBtn" class="help-modal-close" aria-label="Close">
          <span aria-hidden="true">‚úï</span>
        </button>
      </div>
      <div id="helpBody" class="help-modal-body"></div>
    </div>
  </div>

  <!-- i18n -->
  <script src="pcp2cfg_i18n.js"></script>

  <script>
    // -----------------------------
    // State
    // -----------------------------
    let dominoes = []; // { id: number, top: string, bottom: string }
    let currentHelpId = null;

    // -----------------------------
    // Utilities
    // -----------------------------
    function escapeHtml(str) {
      return String(str ?? "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    function showStatus(msg, isError = false) {
      const st = document.getElementById("status");
      st.textContent = msg || "";
      const dark = document.body.classList.contains("dark-mode");
      st.style.color = isError ? (dark ? "#fca5a5" : "darkred")
                              : (dark ? "#e5e7eb" : "#333333");
    }

    function setStatusFromKey(key, params = {}, isError = false) {
      if (!key) return showStatus("", false);
      showStatus(window.t(key, params), isError);
    }

    function normalizeDominoString(s) {
      // Keep it simple and deterministic:
      // - trim outer whitespace
      // - keep inner spaces (if user wants them as terminals)
      // You can later enforce an alphabet, but for teaching the reduction
      // this ‚Äúraw string‚Äù is often convenient.
      return String(s ?? "").trim();
    }

    function allTextOfDominoes(which) {
      // which in {"top","bottom"}
      return dominoes.map(d => (which === "top" ? d.top : d.bottom)).join("");
    }

    function indexSymbols(k) {
      // a1 a2 ... ak
      if (k <= 0) return [];
      const res = [];
      for (let i = 1; i <= k; i++) res.push("a" + i);
      return res;
    }

    function containsForbiddenAi(dominoesLocal) {
      // We want a_i to be fresh terminals not appearing inside any t_i or b_i.
      // For simplicity, we reject if any substring "a<number>" appears.
      // (This is stricter than needed, but keeps the reduction clean in a teaching tool.)
      const text = dominoesLocal.map(d => d.top + " " + d.bottom).join(" ");
      return /a\d+/.test(text);
    }

    function csvEscape(value) {
      const s = String(value ?? "");
      if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
      return s;
    }

    function parseCsv(text) {
      // Minimal CSV: expects header domino_id,top_string,bottom_string (like tm2pcp export)
      // Robust enough for quoted fields with commas.
      const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
      if (lines.length === 0) return [];

      // parse a CSV line into fields
      function parseLine(line) {
        const out = [];
        let cur = "";
        let inQ = false;
        for (let i = 0; i < line.length; i++) {
          const ch = line[i];
          if (inQ) {
            if (ch === '"') {
              if (i + 1 < line.length && line[i + 1] === '"') {
                cur += '"';
                i++;
              } else {
                inQ = false;
              }
            } else {
              cur += ch;
            }
          } else {
            if (ch === '"') inQ = true;
            else if (ch === ",") { out.push(cur); cur = ""; }
            else cur += ch;
          }
        }
        out.push(cur);
        return out.map(s => s.trim());
      }

      const header = parseLine(lines[0]).map(h => h.toLowerCase());
      const iTop = header.indexOf("top_string");
      const iBottom = header.indexOf("bottom_string");
      if (iTop < 0 || iBottom < 0) {
        throw new Error(window.t("status.csv_bad_header"));
      }

      const res = [];
      for (let i = 1; i < lines.length; i++) {
        const f = parseLine(lines[i]);
        const top = normalizeDominoString(f[iTop] ?? "");
        const bottom = normalizeDominoString(f[iBottom] ?? "");
        if (top.length === 0 && bottom.length === 0) continue;
        res.push({ id: res.length + 1, top, bottom });
      }
      return res;
    }

    // -----------------------------
    // Dark mode + language (tm2pcp-like)
    // -----------------------------
    function applyDarkModeFromStorage() {
      const saved = localStorage.getItem("pcp2cfg-dark-mode");
      const isDark = saved === "true";
      document.body.classList.toggle("dark-mode", isDark);
      refreshDarkModeSwitchUI();
    }

    function toggleDarkMode(enabled) {
      document.body.classList.toggle("dark-mode", enabled);
      localStorage.setItem("pcp2cfg-dark-mode", enabled ? "true" : "false");
      refreshDarkModeSwitchUI();
      // keep status color consistent
      const txt = document.getElementById("status")?.textContent;
      if (txt) showStatus(txt, false);
    }

    function getCurrentLang() {
      const saved = localStorage.getItem("pcp2cfg-lang");
      if (saved) return saved;
      return document.documentElement.lang || "en";
    }

    function setCurrentLang(lang) {
      localStorage.setItem("pcp2cfg-lang", lang);
    }

    function refreshLangSwitchUI() {
      const lang = getCurrentLang();
      const btn = document.getElementById("langSwitch");
      const icon = document.getElementById("langIcon");
      if (!btn || !icon) return;
      const isPT = (lang === "pt-BR");
      btn.setAttribute("aria-pressed", isPT ? "true" : "false");
      icon.textContent = isPT ? "üáßüá∑" : "üá¨üáß";
    }

    function refreshDarkModeSwitchUI() {
      const isDark = document.body.classList.contains("dark-mode");
      const btn = document.getElementById("darkModeSwitch");
      const icon = document.getElementById("darkModeIcon");
      if (!btn || !icon) return;
      btn.setAttribute("aria-pressed", isDark ? "true" : "false");
      icon.textContent = isDark ? "üåô" : "‚òÄÔ∏è";
    }

    // -----------------------------
    // Help modal (tm2pcp-like)
    // -----------------------------
    function isHelpOpen() {
      const ov = document.getElementById("helpOverlay");
      return !!(ov && ov.classList.contains("open"));
    }

    function renderHelpModal() {
      if (!currentHelpId) return;
      const titleEl = document.getElementById("helpTitle");
      const bodyEl = document.getElementById("helpBody");
      if (!titleEl || !bodyEl || typeof window.t !== "function") return;

      titleEl.textContent = window.t(`help.${currentHelpId}.title`);
      bodyEl.innerHTML = window.t(`help.${currentHelpId}.body_html`);
    }

    window.refreshHelpModal = function refreshHelpModal() {
      if (isHelpOpen()) renderHelpModal();
    };

    function openHelp(helpId) {
      const ov = document.getElementById("helpOverlay");
      if (!ov) return;
      currentHelpId = helpId;
      renderHelpModal();
      ov.classList.add("open");
      ov.setAttribute("aria-hidden", "false");
      document.body.classList.add("help-open");

      const closeBtn = document.getElementById("helpCloseBtn");
      if (closeBtn) closeBtn.focus();
    }

    function closeHelp() {
      const ov = document.getElementById("helpOverlay");
      if (!ov) return;
      ov.classList.remove("open");
      ov.setAttribute("aria-hidden", "true");
      document.body.classList.remove("help-open");
      currentHelpId = null;
    }

    document.addEventListener("click", (ev) => {
      const target = ev.target;
      const btn = target && (target.closest ? target.closest(".help-btn") : null);
      if (btn && btn.dataset && btn.dataset.help) {
        ev.preventDefault();
        ev.stopPropagation();
        openHelp(btn.dataset.help);
        return;
      }
      const closeBtn = target && (target.closest ? target.closest("#helpCloseBtn") : null);
      if (closeBtn) {
        ev.preventDefault();
        closeHelp();
        return;
      }
      const overlay = document.getElementById("helpOverlay");
      if (overlay && target === overlay && isHelpOpen()) closeHelp();
    });

    document.addEventListener("keydown", (ev) => {
      if (ev.key === "Escape" && isHelpOpen()) {
        ev.preventDefault();
        closeHelp();
      }
    });

    // -----------------------------
    // Domino editor rendering
    // -----------------------------
    function renderDominoTable() {
      const tb = document.getElementById("dominoTbody");
      tb.innerHTML = "";

      for (let i = 0; i < dominoes.length; i++) {
        const d = dominoes[i];

        const tr = document.createElement("tr");

        const tdId = document.createElement("td");
        tdId.innerHTML = `<span class="chip"><strong>${escapeHtml("i=" + d.id)}</strong></span>
                          <span class="chip mono">${escapeHtml("a" + d.id)}</span>`;
        tr.appendChild(tdId);

        const tdTop = document.createElement("td");
        tdTop.innerHTML = `
          <div class="small-note mono" style="margin:0 0 0.15rem 0;">t${d.id}</div>
          <input type="text" value="${escapeHtml(d.top)}" style="width:100%;" aria-label="top string" />
        `;
        tr.appendChild(tdTop);

        const tdBottom = document.createElement("td");
        tdBottom.innerHTML = `
          <div class="small-note mono" style="margin:0 0 0.15rem 0;">b${d.id}</div>
          <input type="text" value="${escapeHtml(d.bottom)}" style="width:100%;" aria-label="bottom string" />
        `;
        tr.appendChild(tdBottom);

        const tdAct = document.createElement("td");
        const del = document.createElement("button");
        del.textContent = window.t("button.delete");
        del.addEventListener("click", () => {
          dominoes.splice(i, 1);
          // reassign ids 1..k
          dominoes = dominoes.map((x, idx) => ({ id: idx + 1, top: x.top, bottom: x.bottom }));
          onDominoesChanged();
        });
        tdAct.appendChild(del);
        tr.appendChild(tdAct);

        // Hook input changes
        const topInput = tdTop.querySelector("input");
        const bottomInput = tdBottom.querySelector("input");
        topInput.addEventListener("input", () => {
          d.top = normalizeDominoString(topInput.value);
          onDominoesChanged(false);
        });
        bottomInput.addEventListener("input", () => {
          d.bottom = normalizeDominoString(bottomInput.value);
          onDominoesChanged(false);
        });

        tb.appendChild(tr);
      }

      // Summary
      const k = dominoes.length;
      document.getElementById("kCount").textContent = String(k);
      const ai = indexSymbols(k);
      document.getElementById("aiSummary").textContent = ai.length ? ai.join(", ") : "‚àÖ";
    }

    // -----------------------------
    // Grammar construction (the reduction)
    // -----------------------------
    function buildGrammarText() {
      const k = dominoes.length;
      if (k === 0) return window.t("grammar.empty");

      // Ensure fresh a_i: we enforce user strings do NOT contain a<number>
      if (containsForbiddenAi(dominoes)) {
        return window.t("grammar.forbidden_ai");
      }

      const lines = [];
      lines.push("S -> T | B");

      // T rules
      const tParts = [];
      for (let i = 1; i <= k; i++) {
        const ti = dominoes[i-1].top;
        tParts.push(`${ti} T a${i}`);
      }
      for (let i = 1; i <= k; i++) {
        const ti = dominoes[i-1].top;
        tParts.push(`${ti} a${i}`);
      }
      lines.push("T -> " + tParts.join(" | "));

      // B rules
      const bParts = [];
      for (let i = 1; i <= k; i++) {
        const bi = dominoes[i-1].bottom;
        bParts.push(`${bi} B a${i}`);
      }
      for (let i = 1; i <= k; i++) {
        const bi = dominoes[i-1].bottom;
        bParts.push(`${bi} a${i}`);
      }
      lines.push("B -> " + bParts.join(" | "));

      return lines.join("\n");
    }

    function refreshGrammarBox() {
      const box = document.getElementById("grammarBox");
      box.textContent = buildGrammarText();
    }

    // -----------------------------
    // Derivation builder (sequence i1..in)
    // -----------------------------
    function parseIndexSequence(s) {
      const raw = String(s ?? "").trim();
      if (raw.length === 0) return [];
      const parts = raw.split(/[\s,;]+/).filter(x => x.length > 0);
      const out = [];
      for (const p of parts) {
        const n = parseInt(p, 10);
        if (!Number.isFinite(n) || n <= 0) return null;
        out.push(n);
      }
      return out;
    }

    function deriveWordVia(which, seq) {
      // which: "T" or "B"
      // Derivation yields:
      // T: t_{i1} ... t_{in} a_{in} ... a_{i1}
      // B: b_{i1} ... b_{in} a_{in} ... a_{i1}
      let prefix = "";
      for (const idx of seq) {
        const d = dominoes[idx - 1];
        prefix += (which === "T" ? d.top : d.bottom);
      }
      let suffix = "";
      for (let j = seq.length - 1; j >= 0; j--) suffix += "a" + seq[j];
      return prefix + suffix;
    }

    function concatTopBottom(seq) {
      let top = "";
      let bottom = "";
      for (const idx of seq) {
        const d = dominoes[idx - 1];
        top += d.top;
        bottom += d.bottom;
      }
      return { top, bottom };
    }

    // Build a (deterministic) derivation tree for the chosen sequence.
    // We render the ‚Äúchain form‚Äù consistent with applying:
    //   T -> t_i T a_i (repeated) then T -> t_i a_i (base)
    //
    // Tree shape:
    //   S
    //   ‚îî‚îÄ T
    //      ‚îú‚îÄ t_{i1} (as terminals, grouped in one node)
    //      ‚îú‚îÄ T
    //      ‚îî‚îÄ a_{i1}
    // and the inner T expands similarly‚Ä¶
    //
    function buildDerivationTree(which, seq) {
      // returns a nested object:
      // { label, kind: 'nonterm'|'term', children: [...] }
      const root = { label: "S", kind: "nonterm", children: [] };
      const top = { label: which, kind: "nonterm", children: [] };
      root.children.push(top);

      function termNode(text) {
        return { label: text, kind: "term", children: [] };
      }
      function nontermNode(lbl) {
        return { label: lbl, kind: "nonterm", children: [] };
      }

      // Build recursive chain for T/B
      function expandAt(pos) {
        const idx = seq[pos];
        const d = dominoes[idx - 1];
        const leftStr = (which === "T" ? d.top : d.bottom);
        const ai = "a" + idx;

        // If last: use base rule: which -> x a_i
        if (pos === seq.length - 1) {
          return [
            termNode(leftStr),
            termNode(ai)
          ];
        }

        // Otherwise: which -> x which a_i
        const inner = nontermNode(which);
        inner.children = expandAt(pos + 1);

        return [
          termNode(leftStr),
          inner,
          termNode(ai)
        ];
      }

      if (seq.length === 0) {
        // No derivation (PCP requires non-empty solution; for explorer we just show S->T/B)
        top.children = [];
      } else {
        top.children = expandAt(0);
      }

      return root;
    }

    function renderTree(containerEl, node) {
      // UL-based tree
      function renderNode(n) {
        const li = document.createElement("li");

        const div = document.createElement("div");
        div.className = "node " + (n.kind === "nonterm" ? "nonterm" : "term");
        div.textContent = n.label;
        li.appendChild(div);

        if (n.children && n.children.length > 0) {
          const ul = document.createElement("ul");
          for (const ch of n.children) {
            ul.appendChild(renderNode(ch));
          }
          li.appendChild(ul);
        }
        return li;
      }

      containerEl.innerHTML = "";
      const wrapper = document.createElement("div");
      wrapper.className = "tree";
      const ul = document.createElement("ul");
      ul.appendChild(renderNode(node));
      wrapper.appendChild(ul);
      containerEl.appendChild(wrapper);
    }

    function buildDerivationsFromUI() {
      if (dominoes.length === 0) {
        setStatusFromKey("status.need_dominoes", {}, true);
        return;
      }

      if (containsForbiddenAi(dominoes)) {
        setStatusFromKey("status.forbidden_ai", {}, true);
        refreshGrammarBox();
        return;
      }

      const seq = parseIndexSequence(document.getElementById("seqInput")?.value);
      if (seq === null) {
        setStatusFromKey("status.bad_sequence", {}, true);
        return;
      }
      if (seq.length === 0) {
        setStatusFromKey("status.empty_sequence", {}, true);
        return;
      }

      // Validate indices
      const k = dominoes.length;
      for (const idx of seq) {
        if (idx < 1 || idx > k) {
          setStatusFromKey("status.sequence_out_of_range", { K: k }, true);
          return;
        }
      }

      const { top, bottom } = concatTopBottom(seq);
      const wT = deriveWordVia("T", seq);
      const wB = deriveWordVia("B", seq);

      document.getElementById("topConcat").textContent = top || "Œµ";
      document.getElementById("bottomConcat").textContent = bottom || "Œµ";
      document.getElementById("wordT").textContent = wT || "Œµ";
      document.getElementById("wordB").textContent = wB || "Œµ";

      const match = (wT === wB);
      const matchLine = document.getElementById("matchLine");
      matchLine.innerHTML = match
        ? `<span class="good"><strong>${escapeHtml(window.t("result.match_yes"))}</strong></span> ${escapeHtml(window.t("result.match_explain_yes"))}`
        : `<span class="danger"><strong>${escapeHtml(window.t("result.match_no"))}</strong></span> ${escapeHtml(window.t("result.match_explain_no"))}`;

      // Trees
      const treeT = buildDerivationTree("T", seq);
      const treeB = buildDerivationTree("B", seq);
      renderTree(document.getElementById("treeT"), treeT);
      renderTree(document.getElementById("treeB"), treeB);

      setStatusFromKey(match ? "status.witness_ambiguity" : "status.no_witness", {}, false);
    }

    // -----------------------------
    // Events
    // -----------------------------
    function onDominoesChanged(rebuildOutputs = true) {
      renderDominoTable();
      refreshGrammarBox();
      if (rebuildOutputs) {
        // Clear derivation outputs (avoid stale results)
        document.getElementById("topConcat").textContent = "‚Äì";
        document.getElementById("bottomConcat").textContent = "‚Äì";
        document.getElementById("wordT").textContent = "‚Äì";
        document.getElementById("wordB").textContent = "‚Äì";
        document.getElementById("matchLine").textContent = "";
        document.getElementById("treeT").innerHTML = "";
        document.getElementById("treeB").innerHTML = "";
      }

      // Update status gently
      if (dominoes.length === 0) setStatusFromKey("status.ready_empty", {}, false);
      else setStatusFromKey("status.ready_k", { K: dominoes.length }, false);
    }

    document.getElementById("addDominoBtn").addEventListener("click", () => {
      dominoes.push({ id: dominoes.length + 1, top: "", bottom: "" });
      onDominoesChanged();
    });

    document.getElementById("clearDominoesBtn").addEventListener("click", () => {
      dominoes = [];
      onDominoesChanged();
    });

    document.getElementById("exportCsvBtn").addEventListener("click", () => {
      if (!dominoes.length) {
        setStatusFromKey("status.export_none", {}, true);
        return;
      }
      let csv = "domino_id,top_string,bottom_string\n";
      for (const d of dominoes) {
        csv += `${d.id},${csvEscape(d.top)},${csvEscape(d.bottom)}\n`;
      }
      const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "pcp_dominoes.csv";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      setStatusFromKey("status.export_ok", { K: dominoes.length }, false);
    });

    document.getElementById("csvFile").addEventListener("change", (ev) => {
      const file = ev.target.files && ev.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const parsed = parseCsv(String(e.target.result || ""));
          dominoes = parsed;
          onDominoesChanged();
          setStatusFromKey("status.import_ok", { K: dominoes.length }, false);
        } catch (err) {
          setStatusFromKey("status.import_fail", { ERR: err.message || String(err) }, true);
        }
      };
      reader.readAsText(file);
    });

    document.getElementById("buildDerivBtn").addEventListener("click", buildDerivationsFromUI);

    document.getElementById("exampleBtn").addEventListener("click", () => {
      // A small example (not necessarily solvable) just to show structure.
      // You can replace with any classroom-friendly instance.
      dominoes = [
        { id: 1, top: "ab", bottom: "a" },
        { id: 2, top: "b",  bottom: "bb" },
        { id: 3, top: "a",  bottom: "ba" }
      ];
      onDominoesChanged();
      document.getElementById("seqInput").value = "1,2";
      setStatusFromKey("status.example_loaded", {}, false);
    });

    // Splitter (same feel as tm2pcp)
    function setupSplitter() {
      const container = document.querySelector(".split-container");
      const leftPane = document.getElementById("leftPane");
      const rightPane = document.getElementById("rightPane");
      const divider = document.getElementById("divider");
      if (!container || !leftPane || !rightPane || !divider) return;

      let isDragging = false;
      divider.addEventListener("mousedown", (e) => {
        e.preventDefault();
        isDragging = true;
        document.body.style.userSelect = "none";
      });
      window.addEventListener("mouseup", () => {
        if (isDragging) {
          isDragging = false;
          document.body.style.userSelect = "";
        }
      });
      window.addEventListener("mousemove", (e) => {
        if (!isDragging) return;
        const rect = container.getBoundingClientRect();
        let offsetX = e.clientX - rect.left;

        const min = 260;
        const max = rect.width - 260;
        if (offsetX < min) offsetX = min;
        if (offsetX > max) offsetX = max;

        const leftPercent = (offsetX / rect.width) * 100;
        const rightPercent = 100 - leftPercent;

        leftPane.style.flex = `0 0 ${leftPercent}%`;
        rightPane.style.flex = `0 0 ${rightPercent}%`;
      });
    }

    // Language toggle
    const langBtn = document.getElementById("langSwitch");
    if (langBtn) {
      langBtn.addEventListener("click", () => {
        const cur = getCurrentLang();
        const next = (cur === "pt-BR") ? "en" : "pt-BR";
        window.setLanguage(next);
        setCurrentLang(next);
        refreshLangSwitchUI();

        // re-render UI-dependent text
        window.applyI18n();
        renderDominoTable();
        refreshGrammarBox();
        if (isHelpOpen()) renderHelpModal();
      });
    }

    // Dark mode toggle
    const darkBtn = document.getElementById("darkModeSwitch");
    if (darkBtn) {
      darkBtn.addEventListener("click", () => {
        const isDark = !document.body.classList.contains("dark-mode");
        toggleDarkMode(isDark);
      });
    }

    // Init
    applyDarkModeFromStorage();
    window.initLanguageFromStorage("pcp2cfg-lang"); // uses storage key you pass
    refreshLangSwitchUI();
    refreshDarkModeSwitchUI();
    setupSplitter();

    onDominoesChanged();
  </script>

  <footer class="app-footer">
    <div class="footer-inner">
      <div>
        ¬© <span id="footer-year"></span>
        <a href="https://brunogrisci.github.io/" target="_blank" rel="noreferrer">Prof. Bruno Iochins Grisci</a>
        ‚Äî pcp2cfg (PCP ‚Üí CFG Ambiguity).
      </div>
      <div>
        <span data-i18n="footer.note">Educational tool; no decision procedure for undecidable problems.</span>
      </div>
    </div>
  </footer>

  <script>
    // Footer year
    const y = new Date().getFullYear();
    document.getElementById("footer-year").textContent = String(y);
  </script>
</body>
</html>
